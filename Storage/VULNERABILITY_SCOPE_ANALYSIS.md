# Vulnerability Scope Analysis: AccessViolationException in databento-cpp

## Executive Summary

The AccessViolationException vulnerability **extends beyond Historical.GetRangeAsync()** to multiple databento-cpp APIs. Any method that:
1. Calls databento-cpp functions that hit the Databento API
2. Wraps calls in try/catch (which cannot catch hardware exceptions)
3. Processes HTTP error responses (400/422/500)

is **potentially vulnerable** to process crashes.

---

## Vulnerability Pattern

### Root Cause

When databento-cpp receives an HTTP error response from Databento API:
```
API returns error ‚Üí databento-cpp processes response ‚Üí memory corruption ‚Üí AccessViolationException ‚Üí CRASH
```

### Why Try/Catch Doesn't Help

```cpp
try {
    wrapper->client->SomeMethod(...);  // Crashes here
    return 0;
}
catch (const std::exception& e) {
    // NEVER REACHED - AccessViolationException is a hardware exception
    return -1;
}
```

**All databento-cpp wrapper functions use this pattern.**

---

## Vulnerable APIs - Full List

### üî¥ CRITICAL RISK (Confirmed Crash)

#### 1. Historical Timeseries Query

**Methods**:
- `HistoricalClient.GetRangeAsync()`
- `HistoricalClient.GetRangeToFileAsync()`

**Native Function**: `dbento_historical_get_range()`, `dbento_historical_get_range_to_file()`

**Trigger Conditions**:
- Invalid symbol names (e.g., "CL" instead of "CLZ5")
- Date range too large (exceeds API limits)
- Invalid dataset names
- Any HTTP 400/422 validation error from API

**Status**: ‚úÖ **CONFIRMED CRASH** - reproduced 100%

**Example**:
```csharp
await client.GetRangeAsync(
    "GLBX.MDP3", Schema.Ohlcv1D, ["CL"],  // ‚Üê Invalid symbol
    startTime, endTime);
// Process crashes
```

---

### üü° HIGH RISK (Likely Vulnerable)

#### 2. Live API - Subscribe & Start

**Methods**:
- `LiveClient.SubscribeAsync()` (normal)
- `LiveClient.SubscribeAsync()` (with Replay)
- `LiveClient.SubscribeWithSnapshotAsync()`
- `LiveClient.StartAsync()`

**Native Functions**:
- `dbento_live_subscribe()`
- `dbento_live_subscribe_with_replay()`
- `dbento_live_subscribe_with_snapshot()`
- `dbento_live_start_ex()`

**Trigger Conditions**:
- **Replay mode** with invalid parameters (HIGHEST RISK)
  - Invalid symbols in replay
  - Invalid date ranges in replay
  - Date too far in past
- Invalid dataset names
- Authentication errors (possibly)
- Connection errors (possibly)

**Status**: ‚ö†Ô∏è **NOT TESTED** - needs verification

**Example**:
```csharp
// High risk - replay with invalid symbol
await client.SubscribeAsync(
    "GLBX.MDP3", Schema.Trades, ["CL"],  // ‚Üê Invalid
    startTime: DateTimeOffset.Now.AddDays(-1));
await client.StartAsync();  // ‚Üê Could crash
```

**Mitigating Factors**:
- Normal live subscriptions likely use different error handling (metadata.not_found)
- Replay mode more risky (queries historical data like GetRangeAsync)

---

#### 3. Batch Operations

**Methods**:
- `HistoricalClient.BatchSubmitJobAsync()`
- `HistoricalClient.BatchListJobsAsync()`
- `HistoricalClient.BatchListFilesAsync()`
- `HistoricalClient.BatchDownloadAsync()`

**Native Functions**:
- `dbento_batch_submit_job()`
- `dbento_batch_list_jobs()`
- `dbento_batch_list_files()`
- `dbento_batch_download()`

**Trigger Conditions**:
- Invalid symbols in batch job submission
- Invalid date ranges
- Invalid dataset names
- Invalid job IDs (for list/download operations)
- Any HTTP 400/422/404 validation error

**Status**: ‚ö†Ô∏è **NOT TESTED** - needs verification

**Example**:
```csharp
var job = await client.BatchSubmitJobAsync(
    "GLBX.MDP3", Schema.Ohlcv1D, ["CL"],  // ‚Üê Invalid
    startTime, endTime);
// Could crash if databento-cpp hits same bug
```

---

#### 4. LiveBlocking API

**Methods**:
- `LiveBlockingClient.Subscribe()`
- `LiveBlockingClient.SubscribeWithReplay()`
- `LiveBlockingClient.SubscribeWithSnapshot()`
- `LiveBlockingClient.Start()`

**Native Functions**:
- `dbento_live_blocking_subscribe()`
- `dbento_live_blocking_subscribe_with_replay()`
- `dbento_live_blocking_subscribe_with_snapshot()`
- `dbento_live_blocking_start()`

**Trigger Conditions**:
- Same as Live API above
- **Replay mode** especially risky

**Status**: ‚ö†Ô∏è **NOT TESTED** - needs verification

---

### üü¢ LOW RISK (Metadata/Query Operations)

These methods query metadata from the API but don't process large error responses. Lower risk but still theoretically vulnerable.

#### 5. Metadata Queries

**Methods**:
- `HistoricalClient.ListPublishersAsync()`
- `HistoricalClient.ListDatasetsAsync()`
- `HistoricalClient.ListSchemasAsync()`
- `HistoricalClient.ListFieldsAsync()`
- `HistoricalClient.GetDatasetConditionAsync()`
- `HistoricalClient.GetDatasetRangeAsync()`

**Risk**: LOW
- Simple GET requests
- Less complex error handling
- Smaller response payloads
- But still wrapped in try/catch that can't catch AVE

**Trigger Conditions**:
- Invalid dataset names
- Invalid parameters
- Any HTTP errors

**Status**: ‚ö†Ô∏è **NOT TESTED** - low priority

---

#### 6. Cost/Billing Queries

**Methods**:
- `HistoricalClient.GetRecordCountAsync()`
- `HistoricalClient.GetBillableSizeAsync()`
- `HistoricalClient.GetCostAsync()`
- `HistoricalClient.GetBillingInfoAsync()`
- `HistoricalClient.ListUnitPricesAsync()`

**Risk**: LOW-MEDIUM
- Similar to timeseries queries (validate symbols, dates)
- Could trigger same error processing bug
- But doesn't stream large data payloads

**Trigger Conditions**:
- Invalid symbols
- Invalid date ranges
- Invalid dataset names

**Status**: ‚ö†Ô∏è **NOT TESTED**

---

#### 7. Symbology Resolve

**Methods**:
- `HistoricalClient.SymbologyResolveAsync()`

**Risk**: LOW-MEDIUM
- Validates symbols against API
- Could return errors for invalid symbols
- But designed to handle "not found" gracefully

**Trigger Conditions**:
- Invalid dataset
- Invalid symbol types
- Date range errors

**Status**: ‚ö†Ô∏è **NOT TESTED**

---

### ‚ö™ NO RISK (Local Operations)

These operations don't call databento-cpp API methods - they work with local data only.

#### 8. Symbol Maps

**Methods**:
- `TsSymbolMap` operations
- `PitSymbolMap` operations
- `Metadata` operations

**Risk**: NONE
- Local data structures
- No API calls
- No native error processing

**Status**: ‚úÖ SAFE

---

#### 9. DBN File Reading/Writing

**Methods**:
- `DbnFileReader` operations
- `DbnFileWriter` operations

**Risk**: NONE (or very low)
- Local file operations
- No API calls
- Could still have memory bugs but different pattern

**Status**: ‚úÖ LIKELY SAFE

---

## Risk Matrix

| API Area | Risk Level | Confirmed Crash | Needs Testing | Priority |
|----------|-----------|----------------|---------------|----------|
| **Historical.GetRange** | üî¥ CRITICAL | YES | NO | P0 |
| **Live Replay Mode** | üü° HIGH | NO | YES | P1 |
| **Batch Operations** | üü° HIGH | NO | YES | P1 |
| **LiveBlocking Replay** | üü° HIGH | NO | YES | P1 |
| **Cost/Billing Queries** | üü¢ LOW-MED | NO | YES | P2 |
| **Metadata Queries** | üü¢ LOW | NO | YES | P3 |
| **Symbology Resolve** | üü¢ LOW-MED | NO | YES | P3 |
| **Symbol Maps** | ‚ö™ NONE | NO | NO | - |
| **DBN File I/O** | ‚ö™ NONE | NO | NO | - |

---

## Native Code Analysis

### Vulnerable Pattern Locations

All these native functions use the same vulnerable pattern:

```cpp
// historical_client_wrapper.cpp
dbento_historical_get_range() ‚Üí wrapper->client->TimeseriesGetRange()  // ‚úÖ CONFIRMED CRASH

// live_client_wrapper.cpp
dbento_live_subscribe() ‚Üí wrapper->client->Subscribe()                  // ‚ö†Ô∏è LIKELY VULNERABLE
dbento_live_start_ex() ‚Üí wrapper->client->Start()                       // ‚ö†Ô∏è LIKELY VULNERABLE

// live_blocking_wrapper.cpp
dbento_live_blocking_subscribe() ‚Üí wrapper->client->Subscribe()         // ‚ö†Ô∏è LIKELY VULNERABLE
dbento_live_blocking_start() ‚Üí wrapper->client->Start()                 // ‚ö†Ô∏è LIKELY VULNERABLE

// batch_wrapper.cpp
dbento_batch_submit_job() ‚Üí wrapper->client->BatchSubmitJob()          // ‚ö†Ô∏è LIKELY VULNERABLE
dbento_batch_list_jobs() ‚Üí wrapper->client->BatchListJobs()            // ‚ö†Ô∏è POSSIBLE
dbento_batch_list_files() ‚Üí wrapper->client->BatchListFiles()          // ‚ö†Ô∏è POSSIBLE
dbento_batch_download() ‚Üí wrapper->client->BatchDownload()             // ‚ö†Ô∏è POSSIBLE
```

### Common Pattern

```cpp
DATABENTO_API int dbento_<API>_<method>(...)
{
    try {
        // ... setup code ...

        wrapper->client->SomeMethod(...);  // ‚Üê CRASH POINT

        return 0;
    }
    catch (const std::exception& e) {
        // Never reached for AccessViolationException
        SafeStrCopy(error_buffer, error_buffer_size, e.what());
        return -1;
    }
}
```

**All ~20+ wrapper functions use this pattern.**

---

## Mitigation Strategy

### Universal Approach

Apply mitigation to **ALL** methods that call native databento-cpp functions:

```csharp
[HandleProcessCorruptedStateExceptions]
[SecurityCritical]
private object ExecuteNativeCall(Func<object> nativeCall)
{
    try {
        return nativeCall();
    }
    catch (AccessViolationException ex) {
        _logger?.LogError(ex, "Native code crashed");
        return new DbentoException(
            "Native library crashed. This may be caused by invalid parameters. " +
            "Please verify your inputs and report this issue if it persists.");
    }
}
```

### Priority Implementation

1. **P0 - Historical GetRange** (confirmed crash)
   - Implement immediately
   - Add pre-validation
   - Document limitation

2. **P1 - Live Replay & Batch** (high risk, not tested)
   - Implement same mitigation
   - Add integration tests with invalid params
   - Document limitation

3. **P2 - Cost/Billing Queries** (medium risk)
   - Apply mitigation (easy, low cost)
   - Test with invalid inputs

4. **P3 - Metadata Queries** (low risk)
   - Apply mitigation for completeness
   - Low priority testing

---

## Testing Plan

### Test Matrix

For each HIGH RISK API (P0, P1):

| Test Case | Expected Behavior | Current Behavior | After Fix |
|-----------|------------------|------------------|-----------|
| Invalid symbol | Exception | CRASH | Exception ‚úÖ |
| Invalid dataset | Exception | CRASH? | Exception ‚úÖ |
| Invalid date range | Exception | CRASH? | Exception ‚úÖ |
| Date too old | Exception | CRASH? | Exception ‚úÖ |
| Date in future | Exception | CRASH? | Exception ‚úÖ |
| Empty symbols | Exception | Exception? | Exception ‚úÖ |

### Test Script Template

```csharp
[Test]
public async Task TestAPI_WithInvalidSymbol_ShouldThrowNotCrash()
{
    var client = new HistoricalClientBuilder()
        .WithApiKey(TestApiKey)
        .Build();

    var ex = await Assert.ThrowsAsync<DbentoException>(async () =>
    {
        await client.SomeMethodAsync(
            "DATASET", Schema.Type, ["INVALID_SYMBOL"],
            startTime, endTime);
    });

    Assert.Contains("Invalid symbol", ex.Message);
    // Most important: process didn't crash!
}
```

---

## Recommendations

### Immediate Actions (This Week)

1. ‚úÖ Implement AccessViolationException handling for **HistoricalClient.GetRangeAsync()**
2. ‚úÖ Add pre-validation for HistoricalClient
3. ‚ö†Ô∏è **Extend mitigation to ALL native-calling methods**
4. ‚ö†Ô∏è Test Live Replay mode with invalid parameters
5. ‚ö†Ô∏è Test Batch operations with invalid parameters
6. ‚úÖ Document known limitation

### Short Term (Next Sprint)

1. Create comprehensive test suite for all HIGH RISK APIs
2. Add telemetry/logging for AccessViolationException catches
3. Monitor production for any crashes
4. Submit comprehensive bug report to databento-cpp

### Long Term

1. Work with databento-cpp maintainers to fix root cause
2. After native fix, remove AccessViolationException handling
3. Keep pre-validation (good practice)
4. Add regression tests to prevent reoccurrence

---

## Conclusion

**The vulnerability is WIDESPREAD across databento-cpp.**

- **Confirmed**: Historical GetRange crashes
- **Likely**: Live Replay, Batch operations vulnerable
- **Possible**: All other API methods vulnerable
- **Root Cause**: databento-cpp memory corruption on HTTP errors
- **Mitigation**: Apply to ALL methods that call native code
- **Long-term**: Needs fix in databento-cpp

**Next Step**: Implement universal mitigation for all databento-cpp API calls, prioritizing confirmed/high-risk methods first.

---

## Implementation Checklist

- [ ] Implement mitigation for HistoricalClient.GetRangeAsync
- [ ] Implement mitigation for HistoricalClient.GetRangeToFileAsync
- [ ] Implement mitigation for LiveClient.SubscribeAsync (all overloads)
- [ ] Implement mitigation for LiveClient.StartAsync
- [ ] Implement mitigation for LiveBlockingClient (all methods)
- [ ] Implement mitigation for BatchSubmitJobAsync
- [ ] Implement mitigation for all other Batch methods
- [ ] Implement mitigation for Cost/Billing queries
- [ ] Implement mitigation for Metadata queries
- [ ] Implement mitigation for SymbologyResolveAsync
- [ ] Add integration tests for invalid parameter scenarios
- [ ] Document known limitation in README
- [ ] Submit bug report to databento-cpp
- [ ] Add telemetry for crash catches

